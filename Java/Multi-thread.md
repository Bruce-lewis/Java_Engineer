#### 线程的零散概念
1.  并发和并行的概念
并发：指两个或多个事件在**同一个时间段内**发生。
并行：指两个或多个事件在**同一时刻**发生（同时发生）。
2. 进程和线程
进程：运行中的应用程序。
线程：是进程中的一个执行单元，CPU最小的调度执行单元。
3. 线程调度
分时调度：所有线程轮流获得CPU的执行权。
抢占式调度：线程根据优先级抢用CPU，优先级高的抢用的几率高。
#### 一. 线程的4种创建方式
###### 创建一个类，继承Thread类
1. 创建一个类，继承Thread类, 重写run方法。 
2. 创建该子类，及创建了线程对象。
3. 调用该对象的start方法（开启一个线程，调用run方法）

###### 创建一个类，实现Runnable接口
1. 创建一个类，实现Runnable接口，重写run方法。
2. 创建该类的对象，将该对象作为参数用于创建Thread对象。
3. 调用Thread对象的start方法（开启一个线程， 执行run方法）

上述两种方法更好的是第二种
1. 摆脱了Java类单继承的限制
2. 更好的实现线程间的资源共享，代码可以被多个线程共享。
3. 实现解耦，代码和线程独立。

###### 创建一个类，实现Callable接口
1. 创建一个Callable接口的实现类
2. 重写call方法
3. 创建该类的实例
4. 使用该类的实例，创建一个FutureTask类的实例
5. 使用FutureTask的实例，创建一个Thread类的实例，并调用start方法。
6. 使用FutureTask的实例调用get方法，可以获取到Callable接口实现类的返回值（可以多次调该方法，还有一个isDone方法可以用于在其它线程中判断该线程是否完成）


Callable接口相比Runnable接口的优势
1. call方法可以有返回值，更灵活
2. call方法可以使用throws的方法处理异常
3. Callable接口使用了泛型，可以指定call方法具体的返回值类型

###### 使用线程池
1. ExecutorsService service=  Executors.newFixedThreadPool(10). //创建一个指定大小的线程池
2. serivce.setMaximumPoolSize(50)
3. service.excute(new NumberThread);// 执行指定的线程的操作，需要提供实现Runnable接口或者Callable接口的实现类的对象
4. service.shutdown() //关闭连接池

此方法的好处
1. 提高了程序执行的效率
2. 提高了资源的复用率
3. 可以设置相关参数，对线程池中的线程进行管理

#### 二. 同步代码块和同步方法解决线程安全问题
###### 什么是线程安全问题
指在多线程环境下，多个线程同时访问共享的数据或资源，造成程序的行为不符合预期。

###### 线程同步
1. 同步代码块
   可以同步执行的代码
   synchronized (同步监视器){
	   需要顺序执行的代码，不能同时写
   }
   
2. 同步方法
   用synchronized 修饰方法即可
   
   切记，同步监视器一定要是唯一的类对象，一般情况是this，或者 子类.class(Class类的对象)

3. 锁机制
   lock() 和 unlock() 方法将需要同步执行的代码块包起来，记住需要使用同步监视器调用。

4. synchronized 同步方式 与 Lock对比
   i. synchronized不管是同步方法还是同步代码块，都需要在结束一对{}之后，释放对同步监视器的占用，而Lock通过两个方法控制需要同步的代码，更加灵活。
   ii. Lock作为接口，提供了多种实现类，适合更加复杂的场景。 	
###### 线程同步造成的死锁问题
1. 死锁
   不同的线程各自占用对方需要的==同步资源==不放，且等待对方放弃自己所需要的同步资源。
   或者是对资源上锁后未解锁也会造成死锁。

2. 诱发死锁的因素
   互斥条件：不同线程获取锁的条件是互斥的，这个是解决线程安全问题的核心。
   占用且等待：我占着同步资源1，还等着同步资源2
   不可抢占：我占着同步资源，你抢不走
   循环等待：我等你，你等我

3. 解决死锁
   死锁出现后很难人为干预，只能接预防。
   针对条件1，无法做出任何处理。
   针对条件2，可以考虑一次性申请所有同步资源，无需等待。
   针对条件3， 如果抢不到对方线程已获取的同步资源，就主动释放自身已持有的资源。
   针对条件4，将同步资源改成线性顺序，不会形成循环等待。
   

#### 三.Thread 类的常用方法和生命周期
###### 1. 常用方法
	getName()
	static currentThread()
	start()
	run()
	static sleep()

###### 2. 生命周期
   new
   runnable （runnable分为 就绪和运行，具体看有没有获取到CPU使用权）
   terminated 
   blocked     （线程在醒着呢，会参与CPU的调度，只是没有获取到锁）
   waiting       （线程睡着呢，不会参与CPU调度，主动释放了锁）
   timed_waiting  （线程睡着呢，不会参与CPU调度，可能握着锁，可能没有）

runnable -----------------------------再调用wait方法------------------------------> waiting
runnable <-----------其它线程调用notify方法，立马获取到锁对象-----------------waiting
blocked  <-----------其它线程调用notify方法，但是没有获取到锁-----------------waiting

runnable ------------1. 调用wait（参数）方法 ---------------------------------------> timed_waiting
runnable ------------2. 调用sleep（参数）--------------------------------------------> timed_waiting
runnable <----------1. wait时间到，立马获取到锁对象。-----------------------------timed_waiting
blocked  <---------- 1.waiting时间到，但是没有获取到锁----------------------------timed_waiting
runnable <----------2. wait时间未到，其它线程调notify后立马获取到锁------------timed_waiting
blocked  <------- ---2.其它线程调用notify唤醒了该线程，但是没有获取到锁--------timed_waiting
runnable <----------3.sleep时间到，不用获取锁，因为压根没释放------------------timed_waiting


runnable ------------没有争取到锁对象（但是已经开始运行了哦，CPU已执行线程）-------------> blocked
runnable <----------获取到所对象----------------------------------------------------------------------blocked
![[Pasted image 20250121152314.png]]






###### 3. wait方法和sleep方法的区别
	i. 方法定义的位置不同：wait 是Object的方法，sleep是Thread的静态方法。   
	ii. 使用范围不同：wait（）只能用于同步方法或同步代码块中，sleep（）可以在任何可以需要使用的场景。
	iii. 是否会释放所对象：用在同步方法和同步代码块中时，sleep不会释放，wait会释放。
	iv. 结束阻塞的方式：wait需要执行notify，而sleep需要到时间后自动结束。



#### 四. 线程间的通信机制
###### 1. 线程通信的理解
当多个线程需要有规律的共同完成一项任务（如操作同一份数据），那么线程之间需要一些通信机制，可以协调他们工作。

###### 2. 通信的方法
wait（）：线程一旦执行此方法，就进入waiting状态，同时释放对锁对象。
notify（）：一旦有线程执行notify方法，就会从waiting状态的线程中取一个优先级最高的唤醒，相同优先级就随机，被唤醒的线程从wait的位置继续执行。
notifyAll（）：一旦执行此方法，就会唤醒所有waiting状态的线程。

###### 3. 注意点
上面三个方法的使用，必须在同步代码块或者同步方法中。（JUC中会说Lock需要配合Condition实现线程通信）
三个方法的调用，必须是同步监视器，否则会报IllegalMonitorStateException异常。

